// screens/MeetingSummaryScreen.js
import React, { useState, useCallback } from "react";
import {
  View,
  Text,
  TextInput,
  Alert,
  ActivityIndicator,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
} from "react-native";
import {
  useRoute,
  useNavigation,
  useFocusEffect,
} from "@react-navigation/native";
import RNFS from "react-native-fs";
import { initLlama, releaseAllLlama } from "llama.rn";
import { normalizeArabicText } from "../services/arabicDateNormalizer";
import { useMeetingContext } from "../context/MeetingContext";
import CustomCard from "../components/CustomCard";
import AudioPlayer from "../components/AudioPlayer";
import colors from "../config/colors";
import { safeReleaseWhisper } from "../services/whisperInstance";
import * as Clipboard from "expo-clipboard";
import * as Sharing from "expo-sharing";
import * as FileSystem from "expo-file-system";

// -----------------------------
// Model Configuration
// -----------------------------
const MODEL_FILE = "qwen2.5-3b-instruct-q4_k_m.gguf";
const MODEL_URL = `https://huggingface.co/Qwen/Qwen2.5-3B-Instruct-GGUF/resolve/main/${MODEL_FILE}`;

// -----------------------------
// Helper Functions
// -----------------------------
const validateDatesEnhanced = (dates) => {
  console.log("üîç Validating dates input:", dates);

  if (!Array.isArray(dates)) {
    console.log("‚ùå Input is not an array:", typeof dates);
    return [];
  }

  const validated = dates.map((item, index) => {
    console.log(`üîç Validating item ${index}:`, item);

    // Validate date
    let validDate;
    if (
      item.date &&
      typeof item.date === "string" &&
      /^\d{4}-\d{2}-\d{2}$/.test(item.date)
    ) {
      const dateObj = new Date(item.date);
      if (!isNaN(dateObj.getTime())) {
        validDate = item.date;
      }
    }

    if (!validDate) {
      validDate = new Date().toISOString().split("T")[0];
      console.log(`‚ö†Ô∏è Invalid date for item ${index}, using today:`, validDate);
    }

    // Validate time
    let validTime = "09:00";
    if (
      item.time &&
      typeof item.time === "string" &&
      /^\d{2}:\d{2}$/.test(item.time)
    ) {
      validTime = item.time;
    }

    // Validate title
    let validTitle = "ŸÖŸáŸÖÿ©";
    if (item.title && typeof item.title === "string" && item.title.trim()) {
      validTitle = item.title.toString().trim();
      // Limit title length
      if (validTitle.length > 80) {
        validTitle = validTitle.substring(0, 77) + "...";
      }
    }

    return {
      date: validDate,
      time: validTime,
      title: validTitle,
    };
  });

  console.log("‚úÖ Final validated dates:", validated);
  return validated;
};

// Simple regex-based date extraction as fallback
const simpleDateExtraction = (normalizedText) => {
  console.log("üîç Running simple date extraction as backup...");

  const dateRegex = /\d{4}-\d{2}-\d{2}/g;
  const dates = normalizedText.match(dateRegex) || [];

  console.log("üìÖ Regex found dates:", dates);

  if (dates.length === 0) {
    return [];
  }

  const found = [];

  dates.forEach((date, index) => {
    // Find context around the date
    const dateIndex = normalizedText.indexOf(date);
    const contextStart = Math.max(0, dateIndex - 80);
    const contextEnd = Math.min(normalizedText.length, dateIndex + 80);
    const context = normalizedText.substring(contextStart, contextEnd);

    // Try to extract meaningful context
    let title = `ŸÖŸáŸÖÿ© ŸÖÿ¨ÿØŸàŸÑÿ© ${index + 1}`;

    // Split context into phrases and find relevant ones
    const phrases = context
      .split(/[ÿå.ÿõ]/)
      .filter((phrase) => phrase.trim().length > 5);
    const relevantPhrase = phrases.find(
      (phrase) =>
        phrase.includes(date) ||
        Math.abs(context.indexOf(phrase) - context.indexOf(date)) < 40
    );

    if (relevantPhrase) {
      let cleanTitle = relevantPhrase
        .replace(date, "")
        .replace(/[ŸáŸÄŸÖ]\s*$/, "")
        .replace(/^\s*(ŸäŸàŸÖ|ŸÅŸä|ŸÖŸÜ|ÿ•ŸÑŸâ|ÿ®ÿ™ÿßÿ±ŸäÿÆ)\s*/, "")
        .trim();

      // Take meaningful keywords for title
      const keywords = cleanTitle.split(/\s+/).slice(0, 6).join(" ");
      if (keywords && keywords.length >= 5) {
        title = keywords;
      }
    }

    found.push({
      date: date,
      time: "09:00",
      title: title,
    });
  });

  console.log("üìù Simple extraction results:", found);
  return found;
};

// Enhanced JSON parsing with multiple strategies
const safeParseArrayEnhanced = (str) => {
  if (!str) {
    console.log("‚ùå Empty string provided to parser");
    return [];
  }

  console.log("üîç Attempting to parse:", str.substring(0, 200) + "...");

  const tryParse = (s) => {
    try {
      const parsed = JSON.parse(s.trim());
      if (Array.isArray(parsed)) {
        console.log(
          "‚úÖ Successfully parsed array with",
          parsed.length,
          "items"
        );
        return parsed;
      }
      console.log("‚ö†Ô∏è Parsed but not an array:", typeof parsed);
      return null;
    } catch (error) {
      console.log("‚ùå Parse failed:", error.message.substring(0, 50));
      return null;
    }
  };

  // Strategy 1: Direct JSON parse
  let result = tryParse(str);
  if (result) return result;

  // Strategy 2: Extract from code blocks
  const codeBlockMatches = [/```(?:json)?([\s\S]*?)```/gi, /`([\s\S]*?)`/gi];

  for (const regex of codeBlockMatches) {
    const match = str.match(regex);
    if (match && match[1]) {
      result = tryParse(match[1]);
      if (result) {
        console.log("‚úÖ Success with code block extraction");
        return result;
      }
    }
  }

  // Strategy 3: Extract JSON array patterns
  const arrayPatterns = [/\[[\s\S]*?\]/g, /\{[\s\S]*?\}/g];

  for (const regex of arrayPatterns) {
    const matches = str.match(regex);
    if (matches) {
      for (const match of matches) {
        result = tryParse(match);
        if (result) {
          console.log("‚úÖ Success with array pattern extraction");
          return result;
        }
      }
    }
  }

  console.log("‚ùå All parsing strategies failed");
  return [];
};

// Enhanced date extraction with comprehensive error handling
const extractDatesWithDebugging = async (ctx, normalizedText) => {
  try {
    console.log("üìù Starting enhanced date extraction...");
    console.log("üìä Input text length:", normalizedText.length);
    console.log("üìñ First 200 chars:", normalizedText.substring(0, 200));

    // Step 1: Quick regex check to see if dates exist
    const dateRegex = /\d{4}-\d{2}-\d{2}/g;
    const foundDates = normalizedText.match(dateRegex) || [];
    console.log("üéØ Regex found dates:", foundDates);

    if (foundDates.length === 0) {
      console.log("‚ö†Ô∏è No dates found in text, returning empty array");
      return [];
    }

    // Step 2: Enhanced LLM prompt with better instructions
    console.log("ü§ñ Calling LLM for intelligent extraction...");

    const datesRes = await ctx.completion({
      messages: [
        {
          role: "system",
          content: `ÿ£ŸÜÿ™ ÿÆÿ®Ÿäÿ± ŸÅŸä ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ŸÖŸÜ ÿßŸÑŸÜÿµŸàÿµ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©.

ÿßŸÑŸÖŸáŸÖÿ©:
1. ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ŸÉŸÑ ÿ™ÿßÿ±ŸäÿÆ ÿ®ÿµŸäÿ∫ÿ© YYYY-MM-DD
2. ŸÑŸÉŸÑ ÿ™ÿßÿ±ŸäÿÆÿå ÿßŸÉÿ™ÿ® ŸÖŸáŸÖÿ© ŸàÿµŸÅŸäÿ© ŸÇÿµŸäÿ±ÿ© (15-40 ŸÉŸÑŸÖÿ©) ÿ™ÿ¥ÿ±ÿ≠ ŸÖÿßÿ∞ÿß Ÿäÿ≠ÿØÿ´ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
3. ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ÿ¨ÿØ ŸàŸÇÿ™ ŸÖÿ≠ÿØÿØÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ "09:00"

ÿßŸÑÿ•ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® - JSON ŸÅŸÇÿ∑:
[
  {"date": "YYYY-MM-DD", "time": "HH:MM", "title": "ŸàÿµŸÅ ÿßŸÑŸÖŸáŸÖÿ©"},
  {"date": "YYYY-MM-DD", "time": "HH:MM", "title": "ŸàÿµŸÅ ÿßŸÑŸÖŸáŸÖÿ©"}
]

ŸÇŸàÿßÿπÿØ ÿµÿßÿ±ŸÖÿ©:
- JSON ÿµÿ≠Ÿäÿ≠ ŸÅŸÇÿ∑ÿå ŸÑÿß ŸÜÿµŸàÿµ ÿ•ÿ∂ÿßŸÅŸäÿ©
- ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ÿ¨ÿØ ÿ™Ÿàÿßÿ±ŸäÿÆÿå ÿ£ÿ±ÿ¨ÿπ []
- ÿπŸÜÿßŸàŸäŸÜ ÿßŸÑŸÖŸáÿßŸÖ Ÿàÿßÿ∂ÿ≠ÿ© ŸàŸÖŸÅŸäÿØÿ©`,
        },
        {
          role: "user",
          content: `ÿßÿ≥ÿ™ÿÆÿ±ÿ¨ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ŸàÿßŸÑŸÖŸáÿßŸÖ ŸÖŸÜ ÿßŸÑŸÜÿµ:\n\n${normalizedText.substring(
            0,
            1200
          )}`,
        },
      ],
      temperature: 0.05,
      n_predict: 500,
      stop: ["\n\n", "```", "---"],
      top_p: 0.8,
      top_k: 30,
    });

    console.log("ü§ñ LLM Raw Response:", datesRes.text?.substring(0, 300));

    // Step 3: Parse with enhanced strategies
    let extractedDates = safeParseArrayEnhanced(datesRes.text);

    // Step 5: Final validation
    const validatedDates = validateDatesEnhanced(extractedDates);
    console.log("‚úÖ Final extraction result:", validatedDates.length, "dates");

    return validatedDates;
  } catch (error) {
    console.error("‚ùå Date extraction error:", error);

    // Emergency fallback
    console.log("üÜò Using emergency regex fallback");
    return simpleDateExtraction(normalizedText);
  }
};

// Initialize LLama with optimized settings for Arabic
const initializeLlamaForArabic = async (modelPath) => {
  try {
    console.log("‚öôÔ∏è Initializing LLM with enhanced settings...");

    const ctx = await initLlama({
      model: modelPath,
      n_ctx: 1536, // Increased context window
      n_gpu_layers: 0,
      seed: 42, // Fixed seed for consistency
      temp: 0.05, // Very low temperature
      top_p: 0.8, // Nucleus sampling
      top_k: 30, // Top-k sampling
      repeat_penalty: 1.05, // Light repetition penalty
      n_batch: 8,
      n_threads: 4,
    });

    console.log("‚úÖ LLM initialized successfully");
    return ctx;
  } catch (error) {
    console.error("‚ùå LLM initialization failed:", error);
    throw error;
  }
};

// -----------------------------
// Main Component
// -----------------------------
export default function MeetingSummaryScreen() {
  const navigation = useNavigation();
  const { params = {} } = useRoute();
  const { transcribedText = "", audioUri = "" } = params;
  const { addMeeting } = useMeetingContext();

  const [summary, setSummary] = useState("");
  const [datesArr, setDatesArr] = useState([]);
  const [topic, setTopic] = useState("");
  const [loading, setLoading] = useState(true);
  const [status, setStatus] = useState("‚è≥ ÿ¨ÿßÿ± ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...");

  useFocusEffect(
    useCallback(() => {
      let cancelled = false;

      (async () => {
        try {
          setLoading(true);
          console.log("üöÄ Starting meeting processing...");

          // Free Whisper memory before loading LLM
          await safeReleaseWhisper("pre-llama");

          // Ensure model exists
          const modelPath = `${RNFS.DocumentDirectoryPath}/${MODEL_FILE}`;
          if (!(await RNFS.exists(modelPath))) {
            setStatus("‚¨áÔ∏è ÿ™ŸÜÿ≤ŸäŸÑ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨...");
            console.log("üì• Downloading model...");
            await RNFS.downloadFile({ fromUrl: MODEL_URL, toFile: modelPath })
              .promise;
          }

          setStatus("‚öôÔ∏è ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨...");
          const ctx = await initializeLlamaForArabic(modelPath);

          // Normalize the transcript
          const normalized = normalizeArabicText(transcribedText, new Date());
          console.log("üìù Normalized text length:", normalized.length);
          console.log("üìù Normalized sample:", normalized.substring(0, 300));

          // Step 1: Generate comprehensive summary
          if (!cancelled) {
            setStatus("üìù ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖŸÑÿÆÿµ ÿßŸÑŸÖŸÅÿµŸëŸÑ...");
            console.log("üìù Starting summary generation...");

            const summaryRes = await ctx.completion({
              messages: [
                {
                  role: "system",
                  content: `ÿ£ŸÜÿ™ ŸÖÿ≥ÿßÿπÿØ ÿ∞ŸÉŸä ŸÖÿ™ÿÆÿµÿµ ŸÅŸä ÿ™ŸÑÿÆŸäÿµ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπÿßÿ™ ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ÿ®ÿ¥ŸÉŸÑ ÿ¥ÿßŸÖŸÑ ŸàŸÖŸÅŸäÿØ.

ÿßŸÉÿ™ÿ® ŸÖŸÑÿÆÿµ ŸÖŸÅÿµŸÑ Ÿäÿ™ÿ∂ŸÖŸÜ:

**ŸÜŸàÿπ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ**
- ÿ≠ÿØÿØ ŸÜŸàÿπ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ 

**ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©**
- ŸÑÿÆÿµ ÿ£ŸáŸÖ ÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ ÿßŸÑŸÖŸÜÿßŸÇÿ¥ÿ©
- ÿßÿ∞ŸÉÿ± ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÖŸáŸÖÿ© ŸàÿßŸÑÿ£ÿ±ŸÇÿßŸÖ ŸàÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿØŸÇŸäŸÇÿ©

**ÿßŸÑŸÇÿ±ÿßÿ±ÿßÿ™ ŸàÿßŸÑÿßÿ™ŸÅÿßŸÇŸäÿßÿ™**
- ÿßÿ∞ŸÉÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇÿ±ÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿ™ÿÆÿ∞ÿ©
- ÿßŸÑÿßÿ™ŸÅÿßŸÇÿßÿ™ ŸàÿßŸÑŸÖŸàÿßŸÅŸÇÿßÿ™

**ÿßŸÑŸÖŸáÿßŸÖ ŸàÿßŸÑŸÖÿ≥ÿ§ŸàŸÑŸäÿßÿ™**
- ŸÖŸÜ ÿ≥ŸäŸÇŸàŸÖ ÿ®ŸÖÿßÿ∞ÿß
- ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑŸäÿßÿ™ ÿßŸÑŸÖÿ≠ÿØÿØÿ©


**ÿßŸÑÿÆÿ∑Ÿàÿßÿ™ ÿßŸÑÿ™ÿßŸÑŸäÿ©**
- ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™ ÿßŸÑŸÖŸÇÿ±ÿ±ÿ©
- ÿßŸÑŸÖŸàÿßÿπŸäÿØ ŸàÿßŸÑÿßŸÑÿ™ÿ≤ÿßŸÖÿßÿ™

ŸÇŸàÿßÿπÿØ:
- ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸÇÿ±ÿßÿ™ ŸÖŸÜŸÅÿµŸÑÿ© ŸÖÿπ ÿπŸÜÿßŸàŸäŸÜ Ÿàÿßÿ∂ÿ≠ÿ©
- ÿßÿ≠ÿ™ŸÅÿ∏ ÿ®ÿßŸÑÿ£ÿ≥ŸÖÿßÿ° ŸàÿßŸÑÿ£ÿ±ŸÇÿßŸÖ ŸàÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ŸÉŸÖÿß ŸáŸä
- 300-600 ŸÉŸÑŸÖÿ© ÿ≠ÿ≥ÿ® ÿ∑ŸàŸÑ ÿßŸÑŸÜÿµ
- ŸÜÿµ ÿπÿßÿØŸä ÿ®ÿØŸàŸÜ Markdown ÿ£Ÿà HTML
- ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸÅŸÇÿ∑`,
                },
                {
                  role: "user",
                  content: `ŸÑÿÆÿµ Ÿáÿ∞ÿß ÿßŸÑŸÜÿµ ÿ®ÿßŸÑÿ™ŸÅÿµŸäŸÑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:\n\n${normalized}`,
                },
              ],
              temperature: 0.15,
              n_predict: 800,
            });

            if (!cancelled) {
              const cleanSummary = (summaryRes.text || "")
                .replace(/<.*?>/g, "")
                .replace(/\*\*/g, "")
                .replace(/##/g, "")
                .trim();
              setSummary(cleanSummary);
              console.log("‚úÖ Summary generated, length:", cleanSummary.length);
            }
          }

          // Step 2: Extract dates and create tasks with enhanced method
          if (!cancelled) {
            setStatus("üìÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ŸàÿßŸÑŸÖŸáÿßŸÖ...");
            console.log("üìÖ Starting date extraction...");

            try {
              const extractedDates = await extractDatesWithDebugging(
                ctx,
                normalized
              );
              setDatesArr(extractedDates);

              if (extractedDates.length === 0) {
                console.log("‚ö†Ô∏è No dates extracted");
                setStatus("‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ™Ÿàÿßÿ±ŸäÿÆ ŸÅŸä ÿßŸÑŸÜÿµ");
              } else {
                console.log(
                  `‚úÖ Successfully extracted ${extractedDates.length} dates`
                );
                setStatus(`‚úÖ ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ${extractedDates.length} ŸÖŸáÿßŸÖ ŸÖÿ¨ÿØŸàŸÑÿ©`);
              }
            } catch (dateError) {
              console.error("‚ùå Date extraction failed:", dateError);
              setStatus("‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ");

              // Final fallback
              const fallbackDates = simpleDateExtraction(normalized);
              setDatesArr(fallbackDates);
            }
          }

          if (!cancelled) {
            setStatus("‚úÖ ÿßŸÉÿ™ŸÖŸÑ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ");
          }
        } catch (error) {
          if (!cancelled) {
            console.error("‚ùå Processing error:", error);
            Alert.alert("ÿÆÿ∑ÿ£", error.message || "ŸÅÿ¥ŸÑ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿµ");
            setStatus("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©");
          }
        } finally {
          if (!cancelled) {
            setLoading(false);
          }
        }
      })();

      return () => {
        cancelled = true;
        console.log("üßπ Cleaning up LLM resources...");
        releaseAllLlama().catch(() => {});
      };
    }, [transcribedText])
  );

  const handleSave = async () => {
    if (!topic.trim()) {
      return Alert.alert("ÿÆÿ∑ÿ£", "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÖŸàÿ∂Ÿàÿπ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ");
    }

    try {
      const cleanDates = validateDatesEnhanced(datesArr);
      await addMeeting(
        transcribedText,
        summary,
        cleanDates,
        audioUri,
        topic.trim()
      );
      Alert.alert("‚úÖ", "ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ ÿ®ŸÜÿ¨ÿßÿ≠");
      navigation.goBack();
    } catch (error) {
      console.error("‚ùå Save error:", error);
      Alert.alert("ÿÆÿ∑ÿ£", "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ");
    }
  };

  const formatDatesForDisplay = (dates) => {
    if (!Array.isArray(dates) || dates.length === 0) {
      return "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸáÿßŸÖ ŸÖÿ¨ÿØŸàŸÑÿ©";
    }

    return dates
      .map((item, index) => {
        const timeText = item.time !== "00:00" ? ` | ${item.time}` : "";
        return `${index + 1}. ${item.date}${timeText}\n   ${item.title}`;
      })
      .join("\n\n");
  };

  const handleCopySummary = async () => {
    try {
      await Clipboard.setStringAsync(summary);
      Alert.alert("üìã", "ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑŸÖŸÑÿÆÿµ");
    } catch (error) {
      Alert.alert("ÿÆÿ∑ÿ£", "ŸÅÿ¥ŸÑ ŸÅŸä ŸÜÿ≥ÿÆ ÿßŸÑŸÖŸÑÿÆÿµ");
    }
  };

  const handleShareSummary = async () => {
    try {
      const path = FileSystem.cacheDirectory + "meeting_summary.txt";
      await FileSystem.writeAsStringAsync(path, summary, { encoding: "utf8" });
      await Sharing.shareAsync(path);
    } catch (error) {
      Alert.alert("ÿÆÿ∑ÿ£", "ŸÅÿ¥ŸÑ ŸÅŸä ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖŸÑÿÆÿµ");
    }
  };

  const handleCopyTasks = async () => {
    try {
      const tasksText = formatDatesForDisplay(datesArr);
      await Clipboard.setStringAsync(tasksText);
      Alert.alert("üìã", "ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑŸÖŸáÿßŸÖ");
    } catch (error) {
      Alert.alert("ÿÆÿ∑ÿ£", "ŸÅÿ¥ŸÑ ŸÅŸä ŸÜÿ≥ÿÆ ÿßŸÑŸÖŸáÿßŸÖ");
    }
  };

  // Loading screen
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={colors.primary} />
        <Text style={styles.loadingText}>{status}</Text>
        <Text style={styles.debugInfo}>
          {datesArr.length > 0 && `ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ${datesArr.length} ŸÖŸáÿßŸÖ`}
        </Text>
      </View>
    );
  }

  const formattedTasks = formatDatesForDisplay(datesArr);

  return (
    <View style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        {/* Audio Player */}
        {!!audioUri && <AudioPlayer uri={audioUri} />}

        {/* Meeting Topic Input */}
        <Text style={styles.sectionHeader}>ŸÖŸàÿ∂Ÿàÿπ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ</Text>
        <TextInput
          style={styles.topicInput}
          placeholder="ÿ£ÿØÿÆŸÑ ŸÖŸàÿ∂Ÿàÿπ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ"
          value={topic}
          onChangeText={setTopic}
          multiline={false}
        />

        {/* Summary Card */}
        <CustomCard
          title="ŸÖŸÑÿÆÿµ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ"
          value={summary}
          onChangeText={setSummary}
          height={250}
          items={[
            {
              icon: "content-copy",
              color: colors.secondary,
              onPress: handleCopySummary,
            },
            {
              icon: "share-variant",
              color: colors.secondary,
              onPress: handleShareSummary,
            },
          ]}
        />

        {/* Tasks Card */}
        <CustomCard
          title={`ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÖÿ¨ÿØŸàŸÑÿ© (${datesArr.length})`}
          value={formattedTasks}
          editable={false}
          height={200}
          items={[
            {
              icon: "content-copy",
              color: colors.secondary,
              onPress: handleCopyTasks,
            },
          ]}
        />

        {/* Debug Info (remove in production) */}
        {__DEV__ && (
          <View style={styles.debugContainer}>
            <Text style={styles.debugTitle}>üêõ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±</Text>
            <Text style={styles.debugText}>
              ÿßŸÑŸÜÿµ ÿßŸÑÿ£ÿµŸÑŸä: {transcribedText.length} ÿ≠ÿ±ŸÅ
            </Text>
            <Text style={styles.debugText}>
              ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿ±ÿ¨ÿ©: {datesArr.length}
            </Text>
            <Text style={styles.debugText}>ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©: {status}</Text>
          </View>
        )}
      </ScrollView>

      {/* Save Button */}
      <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
        <Text style={styles.saveButtonText}>ÿ≠ŸÅÿ∏ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ</Text>
      </TouchableOpacity>
    </View>
  );
}

// -----------------------------
// Styles
// -----------------------------
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#f5f5f5",
  },
  scrollContainer: {
    padding: 20,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(0, 0, 0, 0.7)",
  },
  loadingText: {
    marginTop: 16,
    color: "#ffffff",
    fontSize: 16,
    textAlign: "center",
  },
  debugInfo: {
    marginTop: 8,
    color: "#cccccc",
    fontSize: 14,
    textAlign: "center",
  },
  sectionHeader: {
    fontSize: 18,
    fontWeight: "600",
    color: colors.dark,
    marginBottom: 12,
    textAlign: "right",
  },
  topicInput: {
    borderWidth: 1,
    borderColor: "#ddd",
    borderRadius: 8,
    padding: 16,
    backgroundColor: "#ffffff",
    fontSize: 16,
    textAlign: "right",
    marginBottom: 24,
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  saveButton: {
    position: "absolute",
    bottom: 20,
    left: 20,
    right: 20,
    backgroundColor: colors.primary,
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  saveButtonText: {
    color: "#ffffff",
    fontSize: 18,
    fontWeight: "bold",
  },
  debugContainer: {
    marginTop: 20,
    padding: 15,
    backgroundColor: "#333333",
    borderRadius: 8,
  },
  debugTitle: {
    color: "#ffffff",
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 8,
    textAlign: "right",
  },
  debugText: {
    color: "#cccccc",
    fontSize: 14,
    marginBottom: 4,
    textAlign: "right",
  },
});
